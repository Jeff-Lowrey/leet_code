"""
# Difficulty: Medium

# 355. Design Twitter

Design a simplified version of Twitter where users can post tweets, follow/unfollow users, and see a news feed.

**Example:**

<dl class="example-details">
<dt>Input:</dt>
<dd>
["Twitter", "postTweet", "getNewsFeed", "follow", "postTweet", "getNewsFeed", "unfollow", "getNewsFeed"]<br>
[[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]
</dd>
<dt>Output:</dt>
<dd>[null, null, [5], null, null, [6, 5], null, [5]]</dd>
<dt>Explanation:</dt>
<dd>
Twitter twitter = new Twitter();<br>
twitter.postTweet(1, 5); // User 1 posts a new tweet (id = 5).<br>
twitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5]. return [5]<br>
twitter.follow(1, 2);    // User 1 follows user 2.<br>
twitter.postTweet(2, 6); // User 2 posts a new tweet (id = 6).<br>
twitter.getNewsFeed(1);  // User 1's news feed should return a list with 2 tweet ids -> [6, 5]. Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.<br>
twitter.unfollow(1, 2);  // User 1 unfollows user 2.<br>
twitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5], since user 1 is no longer following user 2.
</dd>
</dl>

<details>
<summary><b>üîç SOLUTION EXPLANATION</b></summary>

### INTUITION:
We need to design a system that efficiently handles:
1. Posting tweets with timestamps
2. Managing follow/unfollow relationships
3. Retrieving recent tweets from user and their followees

A combination of hash maps and heaps provides optimal performance.

### APPROACH:
1. **Data Structures**:
   - tweets: dict mapping userId -> list of (tweetId, timestamp) tuples
   - following: dict mapping userId -> set of followed userIds
   - timestamp: global counter for tweet ordering

2. **postTweet**: Add tweet with timestamp to user's tweet list

3. **getNewsFeed**:
   - Collect recent tweets from user and all followees
   - Use max heap to get 10 most recent tweets
   - Heap contains (negative_timestamp, tweetId) for max-heap behavior

4. **follow/unfollow**: Manage following set for each user

### WHY THIS WORKS:
- Hash maps provide O(1) lookup for user data
- Sets provide O(1) follow/unfollow operations
- Heap provides efficient retrieval of top k recent tweets
- Timestamp ensures correct ordering across all users

### EXAMPLE WALKTHROUGH:
```
postTweet(1, 5): user 1 posts tweet 5
follow(1, 2): user 1 follows user 2
postTweet(2, 6): user 2 posts tweet 6
getNewsFeed(1): returns [6, 5] (most recent from user 1 and followees)
unfollow(1, 2): user 1 unfollows user 2
getNewsFeed(1): returns [5] (only user 1's tweets)
```

### TIME COMPLEXITY:
- postTweet: O(1)
- getNewsFeed: O(N log k) where N is total tweets, k=10
- follow: O(1)
- unfollow: O(1)

### SPACE COMPLEXITY:
O(U + T) where U is users, T is total tweets

### EDGE CASES:
- User has no tweets
- User follows no one
- More than 10 tweets in feed
- User follows themselves

</details>
"""


